<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Advanced Networking - Module 1 Chapter 5 - Ethernet</title>

		<meta name="description" content="Abilitante alle certificazioni Cisco CCENT e CCNA">
		<meta name="author" content="Hacklab Cosenza">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Advanced Networking</h1>
					<h2>Routing & Switching:<h2>
					<h2>Introduction to Networks</h2>
					<h3>Chapter 5: Ethernet</h3>
					<p>
						<small><a href="http://hlcs.it">Hacklab Cosenza</a> / Centro di Ricerca su Tecnologia e Innovazione</small>
					</p>
				</section>

				<section>
					<h2>What is Ethernet?</h2>
					<p>Ethernet is a <strong>networking technology</strong> whose standards operate in, and define, Data Link (L2) and Physical (L1) Layers.</p>
					<p>It is the dominant technology <strong>for Local Area Networks</strong>.</p>
					<p>Ethernet specifications comprises <strong>different L1 and L2 variations</strong>, but the frame format and addressing is basically the same across all variants.</p>
				</section>

				<section>
					<h2>Recap: L2 LLC &amp; MAC Sublayer</h2>
					<img src="http://i.imgur.com/MQJ1hQu.jpg" style="width: 30%; height: 30%;">
					<ul>
						<li><strong>LLC</strong>: comunicates with upper layers, implemented in software, independent from the hardware.</li>
						<li><strong>MAC</strong>: does data encapsulation and media access control, as such is implemented in hardware.</li>
						<ul>
							<li><strong>Data Encapsulation</strong>: frame delimiting, addressing, error detection.</li>
							<li><strong>Media Access Control</strong>: CSMA/CD for modern Ethernet (not really needed with today's switches).</li>
						</ul>
					</ul>
				</section>

				<section>
					<h2>MAC Address Structure</h2>
					<p>MAC addressing allows devices to identify frame's destination <strong>without the overhead of deincapsulation</strong>.</p>
					<p>Ethernet MAC addresses are <strong>48 bits</strong> long, expressed as 12 hex digits, split in two parts:</p>
					<ul>
						<li>First 3 bytes are the <strong>Organizationally Unique Identifier (OUI)</strong>. <u>Every Ethernet device produced by one vendor must have a MAC address starting with same OUI</u>.</li>
						<li>Last 3 bytes are vendor-assigned. <u>This part must be unique for every device that has the same OUI</u> (vendor).</li>
					</ul>
					<p>e.g.: e8:11:32:4e:48:6b, e8:11:32 is the OUI assigned to Samsung.</p>
				</section>

				<section>
					<h2>Processing the Ethernet Frame</h2>
					<p>The MAC address is stored in NIC's ROM. When the host boots, <strong>the MAC is copied into the RAM</strong>.</p>
					<p>From then each device can send and receive frames, <strong>attaching source and destination MAC addresses</strong> to it.</p>
					<p>When a device receives a frame, <strong>it checks if its MAC address matches the destination</strong>. If it does, it passes the frame to upper layers. If it doesn't, the frame is discarded.</p>
					<p>MAC addresses can be represented with:</p>
					<ul>
						<li><strong>Dashes</strong>: e8-11-32-4e-48-6b (Windows)</li>
						<li><strong>Colons</strong>: e8:11:32:4e:48:6b (*nix)</li>
						<li><strong>Periods</strong>: e811.324e.486b (Cisco)</li>
					</ul>
				</section>

				<section>
					<h2>Ethernet Frame Attributes</h2>
					<p>Composed by the L3 PDU, and a <strong>header+trailer of control informations</strong>, divided in <em>fields</em>.</p>
					<p>There are two (minimally) different Ethernet frames: the <strong>Ethernet II</strong> (also called DIX) and <strong>IEEE 802.3</strong> Ethernet Standards.</p>
					<p>Ethernet frames minimum size is 64 bytes, max size is 1518 bytes. From IEEE 802.3ac, max size has been extended to 1522 to accomodate for VLANs (Virtual Area Networks).</p>
					<p>Frames &lt; 64 bytes (<em>runt frames</em>) or &gt; 1522 bytes (<em>jumbo frames</em>) get discarded.</p>
				</section>

				<section>
					<section>
						<h2>Ethernet Frame Structure</h2>
						<img src="http://i.imgur.com/mDGaIgC.gif">
					</section>
					<section>
						<h2>Ethernet Frame Structure</h2>
						<ul>
							<li><strong>Preamble</strong>: not formally part of frame, it's a sequence of bytes telling the device to "get ready" for the frame.</li>
							<li><strong>SFD</strong>: <em>Start Frame Delimiter</em>, breaks the preamble pattern and marks the start of the frame.</li>
							<li><strong>Ethertype/Length</strong>: Ethertype in Ethernet II frames, Length of the data field in 802.3 standards. <u>Based on the value contained, the 2 framing styles are distinguished</strong> and can both be used.</u></li>
							<li><strong>Data</strong>: if smaller than 64 bytes, <em>padding</em> is added to respect the minimum length.</li>
							<li><strong>FCS</strong>: <em>Frame Check Sequence</em>, the result of a formula (CRC, <em>Cyclic Redundancy Check</em>) that allows to spot TX errors.</li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h2>Binary and Hex: counting</h2>
						<img src="http://i.imgur.com/tpI3roD.gif">
					</section>
					<section>
						<h2>Binary and Hex: grouping</h2>
						<img src="http://i.imgur.com/37LF4pU.gif">
					</section>
				</section>

				<section>
					<section>
						<h2>How to get your MAC address</h2>
						<h3>Linux</h3>
						<pre><code>utente@host:$ ifconfig eth0
eth0      Link encap:Ethernet  IndirizzoHW e8:11:32:4e:48:6b  
          indirizzo inet:10.87.1.131  Bcast:10.87.1.255  Maschera:255.255.255.0
          indirizzo inet6: fe80::ea11:32ff:fe4e:486b/64 Scope:Link
          indirizzo inet6: fd3c:6b96:5233:0:2874:d02e:50ea:409b/64 Scope:Global
          indirizzo inet6: fd3c:6b96:5233:0:ea11:32ff:fe4e:486b/64 Scope:Global
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:109834859 errors:0 dropped:1 overruns:0 frame:0
          TX packets:106355594 errors:0 dropped:0 overruns:0 carrier:0
          collisioni:0 txqueuelen:1000 
          Byte RX:81573085337 (81.5 GB)  Byte TX:105092321751 (105.0 GB)</code></pre>
					</section>
					<section>
						<h2>How to get your MAC address</h2>
						<h3>Windows</h3>
						<pre><code>C:\>ipfconfig /all
   Scheda Ethernet Connessione alla rete locale (LAN):

   Suffisso DNS specifico per connessione: hlcs.s
   Descrizione . . . . . . . . . . . . . : Scheda Ethernet PCI AMD PCNET Family
   Indirizzo fisico. . . . . . . . . . . : 08-00-27-3B-1B-39
   DHCP abilitato. . . . . . . . . . . . : Sì
   Configurazione automatica abilitata   : Sì
   Indirizzo IP. . . . . . . . . . . . . : 10.0.2.15
   Subnet mask . . . . . . . . . . . . . : 255.255.255.0
   Gateway predefinito . . . . . . . . . : 10.0.2.2
   Server DHCP . . . . . . . . . . . . . : 10.0.2.2
   Server DNS . . . . . . . . . . . . .  : 10.0.2.3
   Lease ottenuto. . . . . . . . . . . . : martedì 11 novembre 2014 17.50.27
   Scadenza lease . . . . . . . . . . .  : mercoledì 12 novembre 2014 17.50.27</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Unicast MAC Address</h2>
						<h3>e8:11:32:4e:48:6b</h3>
						<p>Combines with a <strong>unicast network address</strong>, like an IP unicast address (eg. 192.168.1.127), to deliver the frame to a <u>single</u> host.</p>
					</section>
					<section>
						<h2>Broadcast MAC Address</h2>
						<h3>ff:ff:ff:ff:ff:ff</h3>
						<h4>All 1s!</h4>
						<p>Combines with a <strong>broadcast network address</strong>, like a broadcast IP address (eg. 192.168.1.255), to deliver the frame to <u>every</u> host on a <u>local</u> network.</p>
						<p>Many fundamentals network protocols and mechanisms, like ARP and DHCP, <strong>rely on broadcast</strong>.</p>
					</section>
					<section>
						<h2>Multicast MAC Address</h2>
						<h3>01:00:5E:[00:00:00-7F:FF:FF]</h3>
						<p>Combines with a <strong>multicast network address</strong>, like the multicast IP allocation (224.0.0.0 - 239.255.255.255), to deliver the frame to <u>a host group</u>.</p>
					</section>
				</section>

				<section>
					<section>
						<h2>Layer 1 and Layer 2 Devices</h2>
						<ul>
							<li>An <strong>hub</strong> is a "Layer 1 device" because it <u>makes no decision</u> and only deals with <u>physically replicating every bit</u> received on one port on every other port.</li>
							<ul>
								<li>Ethernet was developed with a <strong>multi-access bus logical topology</strong> in mind, where <u>devices would contest the media</u> in a network segment.</li>
								<li>Since with hubs every host receives every frame, MAC addresses were used as a <strong>solution to identify correct source and destination</strong>.</li>
							</ul>
						</ul>
					</section>
					<section>
						<h2>Layer 1 and Layer 2 Devices</h2>
						<ul>
							<li>A <strong>switch</strong> is a "Layer 2 device", because it takes <u>decisions based on the MAC address of the Ethernet frame</u> (an L2 PDU), regardless of the content coming from upper layers.</li>
							<ul>
								<li>Switches enabled an "uncontested" Ethernet, because they <u>direct traffic only where necessary</u> and also they can "store" the frame while <u>waiting for the media to be available</u>.</li>
								<li>As a result of this, plus the introduction of full-duplex capabilities, means <u>modern Ethernet does not have to worry about collisions</u> anymore.</li>
							</ul>
						</ul>
					</section>
				</section>

				<section>
					<h2>MAC Table</h2>
					<p>The switch has to build a <strong>MAC Table</strong> to make its decisions.</p>
					<p>It's also called <strong>CAM table</strong> (<em>content addressable memory</em>).</p>
					<ul>
						<li>The MAC table associates each <strong>port with MAC addresses</strong>.</li>
						<li>It is populated by <strong>examining source MAC adresses</strong>.</li>
					</ul>
					<img src="http://i.imgur.com/AZ06xwX.jpg">
				</section>

				<section>
					<section>
						<h2>How a Switch Works</h2>
						<h3>Learning</h3>
						<ul>
							<li>The MAC table is empty when the switch is first turned on.</li>
							<li>When a frame is received, it looks at the <strong>source MAC address</strong>.</li>
							<ul>
								<li>If it's not on the table, <strong>an association is added</strong> between the source MAC and the incoming port.</li>
								<li>If it was already on the table, the <strong>aging timer</strong> of the association is reset. Maximum aging time is usually 5 min.</li>
							</ul>
						</ul>
					</section>
					<section>
						<h2>How a Switch Works</h2>
						<h3>Forwarding</h3>
						<ul>
							<li>Then, it looks at the <strong>destination MAC address</strong></li>
							<ul>
								<li>If It's not on the table it <strong>forwards the frame to all ports</strong> except the incoming port. This is called <em>flooding</em>.</li>
									<ul>
										<li><strong>Only the destination will reply</strong> with a unicast frame. The switch can now add the missing association in the table.</li>
									</ul>
								<li>If It's already on the table, the switch forwards the frame to the <strong>associated exit port</strong>.</li>
							</ul>
							<li>Once all the associations have been learned the switch doesn't need flooding anymore.</li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h2>Switching Methods</h2>
						<img src="http://i.imgur.com/dMGP8Ue.gif">
						<small>The figure above shows how many bytes of an incoming frame a switch needs to receive before making a forwarding decision, dependent of the switching method in use.</small>
					</section>
					<section>
						<h2>Switching Methods</h2>
						<h3>Store &amp; Fordward</h3>
						<p><em>Store and Forward Switching</em> makes a forwarding decision only <strong>after receiving the entirety of the frame</strong> and error-checking it.</p>
						<p>It is the main switching method in a Cisco LAN switch.</p>
						<p>After receiving the frame, the switch computes its <em>checksum</em> (FCS). If it matches the FCS value the frame is forwarded through the appropriate exit port, <strong>otherwise it is dropped</strong>.</p>
					</section>
					<section>
						<h2>Switching Method: Cut-Through</h2>
						<p><em>Cut-Through Switching</em> makes a forwarding decision <strong>as soon as "enough" bytes</strong> of the frame as been received.</p>
						<p>The actual forwarding process begins <strong>before the frame has been completely received</strong>.</p>
						<p>There are two variants, both <strong>not verifying the checksum</strong>:</p>
						<ul>
							<li><strong>Rapid Frame</strong> - The switch forwards the frame <u>as soon as the destination MAC address is received</u>. This means it only needs the first 8+6=14 bytes of the frame.</li>
							<li><strong>Fragment Free</strong> - The switch waits for the first 64 bytes (<em>collision window</em>). <u>If no fragmentation is detected it then forwards the frame</u>.</li>
						</ul>
					</section>
					<section>
						<h2>Switching Methods: Comparison</h2>
						<ul>
							<li>With Store &amp; Forward switching <strong>invalid frames are never forwarded</strong>.</li>
							<li>Cut-Through switching forwards <strong>almost every invalid frame</strong>.</li>
							<li>Cut-through provides <strong>significantly better latencies</strong>.</li>
							<li>In a network with a <strong>high error rate</strong>, C-T switching becomes counterproductive, wasting bandwidth with invalid frames.</li>
							<li>Fragment-Free is usually the best <strong>compromise</strong>: a little better error checking with virtually no increase in latency.</li>
						</ul>
					</section>
				</section>

				<section>
					<h2>Switch Buffers</h2>
					<p>A <em>buffer</em> is a memory with the purpose of temporarily queuing something, <strong>continuously filled and emptied</strong>.</p>
					<p>Switches use two types of memory buffer to <strong>store Ethernet frames</strong> before forwarding them:</p>
					<ul>
						<li><strong>Port-based</strong>: each port has its own queue of frames, and a frame must wait every frame in front.</li>
						<ul>
							<li>A frame is <strong>never moved off the queue and into a less congested queue</strong> of another viable destination port.</li>
						</ul>
						<li><strong>Shared</strong>: there's a single queue for all ports, and each frame has a destination port linked to it.</li>
						<ul>
							<li><strong>Frames don't have to move</strong>, just being re-linked to a different outgoing port; <strong>variable allocation</strong> of memory.</li>
						</ul>
					</ul>
				</section>

				<section>
					<h2>Matching Speed, Duplex, Cable</h2>
					<ul>
						<li>The switch port and the device connected to it <strong>must operate at the same speed and duplex</strong>.</li>
						<ul>
							<li>They can be manually set, but by default almost every device has <strong>autonegotiation</strong> for both settings enabled.</li>
							<li>Autonegotiation must be on on both sides; Gigabit ports can only operate in full-duplex mode.</li>
						</ul>
						<li><em>Ethernet over copper twisted pairs</em> has 2 wiring variants: the <strong>cable connecting switch and device must be correct</strong>.</li>
						<ul>
							<li>However switches have <strong>Auto-MDIX</strong> capability that <strong>reconfigures the interfaces no matter the cable</strong> in use.</li>
						</ul>
					</ul>
				</section>

				<section>
					<section>
						<h2>ARP: Address Resolution Protocol</h2>
						<p>To send a frame, we need:</p>
						<ul>
							<li><strong>Source IP Address</strong>: of course I know my own!</li>
							<li><strong>Source MAC Address</strong>: of course I know my own!</li>
							<li><strong>Destination IP Address</strong>: provided by higher layers (like L7's DNS), or <em>we just know</em>.</li>
							<li><strong>Destination MAC Address</strong>: <u>that's what ARP is for</u>.</li>
						</ul>
					</section>
					<section>
						<h2>ARP: Address Resolution Protocol</h2>
						<p>What ARP does is:</p>
						<ul>
							<li>Associating (<em>resolving</em>) <u>IP addresses to corresponding MAC addresses</u>.</li>
							<li>Maintaining a table of these associations (<em>mappings</em>), the <strong>ARP table/cache</strong>.</li>
							<li>Provides a mechanism to query the ARP table, through <strong>ARP requests and replies</strong>.</li>
						</ul>
					</section>
				</section>

				<section>
					<h2>How ARP operates</h2>
					<p>When an host needs to determine the destination MAC, <strong>it searches the destination IP in the ARP table</strong> to see if there's already a mapping.</p>
					<ul>
						<li>If there is, it uses the MAC and generates the frame.</li>
						<li>If there isn't, then it can't generate the frame until <u>it has populated the ARP table</u>.</li>
					</ul>
					<p>It has two way of doing so, an <em>active</em> and a <em>passive</em> one:</p>
					<ul>
						<li><strong>Address Learning</strong>: <em>the mapping comes to you</em>.</li>
						<li><strong>ARP Requests</strong>: <em>you search for the mapping</em>.</li>
					</ul>
				</section>

				<section>
					<section>
						<h2>How ARP operates: Address Learning</h2>
						<p>Simple: the host <em>listens</em> to incoming frames, <strong>reads the source MAC and IP addresses</strong>, and if this mapping is not already on the ARP table, <strong>the mapping is added to it</strong>.</p>
					</section>
					<section>
						<h2>How ARP operates: ARP Requests</h2>
						<ul>
							<li>The host generates a <strong>L2 broadcast</strong> frame known as an ARP Request, <u>containing the IP address whose MAC address it wants to know</u>, that will be received by every host.</li>
							<li>Only the host that has the the IP address included in the ARP request will reply, with <strong>a (unicast) ARP Reply</strong> <u>containing its own MAC address</u>.</li>
							<li>The original host <strong>can now create the appropriate entry</strong> in its ARP cache.</li>
						</ul>
						<p>ARP table entries are <em>time stamped</em>, they <em>expire</em>, and can be <em>static</em>.</p>
						<p>If no host replies to the ARP request, <strong>the encapsulation failes, the frame is aborted</strong> and an error might be reported to the upper layers.</p>
					</section>
					<section>
						<h2>How ARP operates for remote networks</h2>
						<p>What we've seen until now <strong>only works on a local network</strong>, because broadcast (like ARP requests) doesn't propagate to other networks.</p>
						<p>When the host recognizes that the IP address of which it wants to know the MAC address it's part of a remote network, it has to forward the frame to a (default) gateway.</p>
						<p><strong>This means it has to use the (default) gateway MAC address as the destination</strong>.</p>
					</section>
				</section>

				<section>
					<section>
						<h2>ARP commands</h2>
						<h3>Consulting the ARP table on Linux</h3>
						<pre><code>stefanauss@barney:~$ arp -a
? (10.87.23.1) associato a c0:4a:00:fc:28:9c [ether] su eth0
stefanauss@barney:~$ cat /proc/net/arp
IP address       HW type     Flags       HW address            Mask     Device
10.87.23.1       0x1         0x2         c0:4a:00:fc:28:9c     *        eth0</code></pre>
					</section>
					<section>
						<h2>ARP commands</h2>
						<h3>Consulting the ARP table on Windows</h3>
						<pre>arp -a</pre>
					</section>
					<section>
						<h2>ARP commands</h2>
						<h3>Consulting the ARP table on Cisco IOS</h3>
						<pre>show ip arp</pre>
					</section>
					<section>
						<h2>ARP commands</h2>
						<h3>Manipulating ARP table entries on Windows</h3>
					</section>
					<section>
						<h2>ARP commands</h2>
						<h3>Manipulating ARP table entries on Linux</h3>
					</section>
				</section>

				<section>
					<section>
						<h2>ARP Issues</h2>
						<h3>Broadcast Overhead</h3>
						<p>The <strong>impact of broadcast communication</strong> can be very heavy for large enterprise networks and can greatly reduce throughput.</p>
						<p>ARP broadcast traffic decreases significantly once the ARP tables start to get populated.</p>
					</section>
					<section>
						<h2>ARP Issues</h2>
						<h3>ARP Poisoning/Spoofing</h3>
						<p>By issuing <strong>fake ARP replies</strong> that tries to get the wrong association on the ARP tables, an attacker can <strong>capture traffic originally intended for another host</strong> on the network.</p>
						<p>Mitigation for ARP poisoning includes:</p>
						<ul>
							<li>authorizing only specific MAC addresses.</li>
							<li>using static ARP entries (<em>ARP Binding</em>).</li>
							<li>encrypting traffic in the upper layers.</li>
						</ul>
					</section>
				</section>

				<section>
					<h1>End of Lesson</h1>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
